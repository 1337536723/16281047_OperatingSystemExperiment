# 实验一实验报告

> 孙汉武	16281047	安全1601

[TOC]

## Task 1 系统调用实验 

### 1.1 直接调用和汇编中断调用系统调用getpid

#### C语言直接调用

1. 实验步骤

   + 源代码`getpid_c.c`：

   ```c
   #include<stdio.h>
   #include<unistd.h>
   int main()
   {
   	pid_t pid;
   	pid = getpid();
   	printf("%d\n",pid);
   	return 0;
   }
   ```

   + 编译源代码，得到可执行文件getpid_c
   + 执行可执行文件，得到程序的pid

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ubgong5rj31dv02ugmj.jpg" width="600">

2. 查看getpid的系统调用号

   64位Linux系统的系统调用列表保存在/usr/include/asm/unistd_64.h（32位在unistd_32.h）,查看该文件可得到**getpid的系统调用号为39**

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ubqmfy1zj314j021aak.jpg" width="600">

#### 汇编中断调用

1. 实验步骤

   + 源代码`getpid_asm.c`：

   ```c
   #include <stdio.h>  
   #include <unistd.h>  
   int main()  
   {  
               pid_t pid;  
           asm volatile (  
                "movl $0x14,%%eax\n\t"  
                "int $0x80\n\t"  
                "movl %%eax,%0\n\t"  
                :"=m"(pid)  
           );  
           printf(" current PID is : %u\n",pid);  
   		return 0;
   }
   ```

   + 编译源码，得到可执行文件getpid_asm
   + 执行可执行文件，得到程序的pid

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ucbcwy99j3176020aai.jpg" width="600">

2. getpid的中断向量号

   在汇编代码`movl $0x14,%%eax\n\t`可以看到getpid的**中断向量号为14**

### 1.2 习题1.13

#### 使用C语言

1. 实验步骤

   + 源代码`print_c.c`:

   ```c
   #include<stdio.h>
   int main()
   {
   	printf("Hello World!\n");
   	return 0;
   }
   ```

   + 编译源码，得到可执行文件print_c
   + 执行文件，屏幕打印Hello World

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ucoz1v54j31ap02u3zp.jpg" width="600">

#### 使用汇编

1. 实验步骤

   + 源代码`print_asm.asm`:

   ```asm
   section data
   msg db "Hello World",0xA
   len equ $-msg
   section .text
   	global _start
   _start:
   	mov eax,4
   	mov ebx,1
   	mov ecx,msg
   	mov edx,len
   	int 0x80
   	mov eax,1
   	xor ebx,ebx
   	int 0x80
   ```

   + 汇编源码，得到对象文件print_asm.o
   + 链接得到可执行文件print_asm
   + 执行可执行文件print_asm,屏幕打印Hello World

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ucyoghnwj31dm03sjsw.jpg" width="600">

### 1.3 阅读pointer

## Task 2 并发实验

### 2.1 实验步骤

1. 编写`cpu.c`代码，代码如下：

   ```c
   #include<stdio.h>
   #include<stdlib.h>
   #include<sys/time.h>
   #include<assert.h>
   #include<unistd.h>
   int main(int argc,char *argv[])
   {
   	if (argc!=2)
   	{
   		fprintf(stderr,"usage:cpu<string>\n");
   		exit(1);
   	}
   	char *str=argv[1];
   	while(1)
   	{
   		sleep(1);
   		printf("%s\n",str);
   	}
   	return 0;
   }
   ```

2. 编译源码cpu.c，得到可执行文件cpu

   ```shell
   gcc cpu.c -o cpu 
   ```

3. 执行cpu程序

   ```shell
   ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D 
   ```

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0unxdllbbj31ha0s6hdt.jpg" width="600">

### 2.2 实验结果

1. 通过上面的截图可以看到这四个不同的程序没有规律



