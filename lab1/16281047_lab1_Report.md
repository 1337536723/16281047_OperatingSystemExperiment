# 实验一实验报告

> 孙汉武	16281047	安全1601

[TOC]

## Task 1 系统调用实验 

### 1.1 直接调用和汇编中断调用系统调用getpid

#### C语言直接调用

1. 实验步骤

   + 源代码`getpid_c.c`：

   ```c
   #include<stdio.h>
   #include<unistd.h>
   int main()
   {
   	pid_t pid;
   	pid = getpid();
   	printf("%d\n",pid);
   	return 0;
   }
   ```

   + 编译源代码，得到可执行文件getpid_c
   + 执行可执行文件，得到程序的pid

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ubgong5rj31dv02ugmj.jpg" width="600">

2. 查看getpid的系统调用号

   64位Linux系统的系统调用列表保存在/usr/include/asm/unistd_64.h（32位在unistd_32.h）,查看该文件可得到**getpid的系统调用号为39**

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ubqmfy1zj314j021aak.jpg" width="600">

#### 汇编中断调用

1. 实验步骤

   + 源代码`getpid_asm.c`：

   ```c
   #include <stdio.h>  
   #include <unistd.h>  
   int main()  
   {  
               pid_t pid;  
           asm volatile (  
                "movl $0x14,%%eax\n\t"  
                "int $0x80\n\t"  
                "movl %%eax,%0\n\t"  
                :"=m"(pid)  
           );  
           printf(" current PID is : %u\n",pid);  
   		return 0;
   }
   ```

   + 编译源码，得到可执行文件getpid_asm
   + 执行可执行文件，得到程序的pid

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ucbcwy99j3176020aai.jpg" width="600">

2. getpid的中断向量号

   在汇编代码`movl $0x14,%%eax\n\t`可以看到getpid的**中断向量号为14**

### 1.2 习题1.13

#### 使用C语言

1. 实验步骤

   + 源代码`print_c.c`:

   ```c
   #include<stdio.h>
   int main()
   {
   	printf("Hello World!\n");
   	return 0;
   }
   ```

   + 编译源码，得到可执行文件print_c
   + 执行文件，屏幕打印Hello World

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ucoz1v54j31ap02u3zp.jpg" width="600">

#### 使用汇编

1. 实验步骤

   + 源代码`print_asm.asm`:

   ```asm
   section data
   msg db "Hello World",0xA
   len equ $-msg
   section .text
   	global _start
   _start:
   	mov eax,4
   	mov ebx,1
   	mov ecx,msg
   	mov edx,len
   	int 0x80
   	mov eax,1
   	xor ebx,ebx
   	int 0x80
   ```

   + 汇编源码，得到对象文件print_asm.o
   + 链接得到可执行文件print_asm
   + 执行可执行文件print_asm,屏幕打印Hello World

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0ucyoghnwj31dm03sjsw.jpg" width="600">

### 1.3 阅读pointer

## Task 2 并发实验

### 2.1 实验步骤

1. 编写`cpu.c`程序，代码如下：

   ```c
   #include<stdio.h>
   #include<stdlib.h>
   #include<sys/time.h>
   #include<assert.h>
   #include<unistd.h>
   int main(int argc,char *argv[])
   {
   	if (argc!=2)
   	{
   		fprintf(stderr,"usage:cpu<string>\n");
   		exit(1);
   	}
   	char *str=argv[1];
   	while(1)
   	{
   		sleep(1);
   		printf("%s\n",str);
   	}
   	return 0;
   }
   ```

2. 编译源码cpu.c，得到可执行文件cpu

   ```shell
   gcc cpu.c -o cpu 
   ```

3. 执行cpu程序

   ```shell
   ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D 
   ```

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0unxdllbbj31ha0s6hdt.jpg" width="600">

4. 程序功能解释：

   该程序的接受且仅能接受一个参数，当正确接受到参数的时候打印该参数，没有正确接受参数的时候，通过打印标准错误输出提示用户正确输入参数。

### 2.2 实验结果

通过上面的实验可以观察到四个进程的运行顺序并没有规律。对于这种现象的解释如下：

+ 现代操作系统中进程的运行都是并发实现的，并不是像以前的单道批处理的操作系统那样，总是按照进程进入内存的先后顺序来执行，因此进程的运行的顺序并没有规律。
+ 现代CPU一般都是多核CUP（我的电脑是四核），因此实验中的四个进程可能也不是简单的在一个CPU中并发，而有可能是在多个CPU核心中并行运行，也有可能某两个进程在一个CPU核心中并发运行，和其他的进程在不同的CPU核心中并行运行。所以进程的运行顺序并没有特别的规律。

## Task 3 内存分配实验

### 3.1 实验步骤 

1. 编写`mem.c`程序，代码如下：

   ```c
   #include<unistd.h>
   #include<stdio.h>
   #include<stdlib.h>
   #include<assert.h>
   int main(int argc,char *argv[])
   {
   	int *p = malloc(sizeof(int));
   	assert(p!=NULL);
   	printf("(%d) address pointed to by p: %p\n",getpid(),p);
   	*p=0;
   	while(1)
   	{
   		sleep(1);
   		*p=*p+1;
   		printf("(%d) p: %d\n",getpid(),*p);
   	}
   	return 0;
   }
   ```

2. 编译源码`mem.c`，得到可执行程序`mem`

   ```shell
   gcc mem.c -o mem
   ```

3. 执行mem程序

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0vhetwcdej318m0my1kx.jpg" width="600">

4. 程序功能解释

   mem程序的功能是首先申请一个int大小的内存地址，并打印进程号和内存地址。之后就是对该内存地址保存的值进行循环累加操作

### 3.2 实验结果

1. 实验现象

   通过内存分配实验可以观察到如下现象：

   + 两个进程申请分配的内存地址一样，所以两个进程共享同一块物理内存区域。
   + 对于每个进程而言每个进程一直在该分配的内存空间进行累加操作，并且两个进程之间没有相互影响。

2. 现象解释

   + balabala

3. 

## Task 4 共享问题

### 4.1 实验步骤

1. 编写程序`thread.c`,源码如下：

   ```c
   #include<stdio.h>
   #include<stdlib.h>
   #include<pthread.h>
   volatile int counter=0;
   int loops;
   void *worker(void *arg)
   {
   	int i;
   	for(i=0;i<loops;i++)
   	{
   		counter++;
   	}
   	return NULL;
   }
   int main(int argc,char *argv[])
   {
   	if(argc!=2)
   	{
   		fprintf(stderr,"usage: thread <value>\n");
   		exit(1);
   	}
   	loops=atoi(argv[1]);
   	pthread_t p1,p2;
   	printf("Initial value: %d\n",counter);
   	pthread_create(&p1,NULL,worker,NULL);
   	pthread_create(&p2,NULL,worker,NULL);
   	pthread_join(p1,NULL);
   	pthread_join(p2,NULL);
   	printf("Final value: %d\n",counter);
   	return 0;
   }
   ```

2. 编译源码`thread.c`

   ```shell
   gcc -o thread -lpthread thread.c 
   ```

3. 执行thread程序

   + `./thread 1000`

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0vj3nf2acj316002xada.jpg" width="600">

   + `./thread 10000`

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g0vj4zp4z3j315v02x0vy.jpg" width="600">

4. 程序功能解释






