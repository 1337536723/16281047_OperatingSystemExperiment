# 实验二实验报告

> 孙汉武	16281047	安全1601

[TOC]

## Task 1 

### 1.1 实验步骤

1. 打开一个vi进程

2. 通过ps命令找到名字为vi的进程，命令如下

   ```shell
   ps -auxc | grep vi$
   ```

   <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g11ggp7dkpj311c028dgg.jpg" width="600">

   这里对该命令中的参数做出解释

   + `-aux`:	显示所有进程
   + `-c`:            将command列输出更改为可执行文件名而不是命令名称
   + `grep`         正则表达式搜索
   + `vi$`           匹配结尾为vi字符串    

   这里对ps命令的输出结果每一列的含义做出解释，`ps -aux`命令的输出结果一共有十一列，从左往右分别是：

| 列名 | USER           | PID    | %CPU          | %MEM           | VSZ      | RSS            |
| ---- | -------------- | ------ | ------------- | -------------- | -------- | -------------- |
| 含义 | 进程所属用户名 | 进程ID | 占用CPU百分比 | 占用内存百分比 | 虚拟大小 | 驻留中页的数量 |
| 示例 | ubuntu         | 13716  | 0.0           | 0.5            | 40384    | 10144          |

| 列名 | TTY    | STAT     | START    | TIME        |      |
| ---- | ------ | -------- | -------- | ----------- | ---- |
| 含义 | 终端ID | 进程状态 | 开始时间 | 累计CPU时间 |      |
| 实例 | pts/2  | S+       | 20:33    | 0:00        |      |

 3. 寻找vi的父进程，直到init进程为止

    使用如下命令查看指定进程的父进程的PID：

    ```shell
    ps -eo pid,ppid,user,command | grep -w ^.<pid>
    ```

    > 说明：
    >
    > 1. `-eo`	表示按照指定格式输出，这里指定的格式是pid,ppid,user,command
    > 2. \<pid\>     是要查询的pid号

    \<pid\>填写查询进程的pid.

    + 通过步骤2可知vi的pid为13716，所以查询vi的父进程

      ```shell
      ps -eo pid,ppid,user,command | grep -w 13716
      ```

      <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g11j2vzl5sj319802adgf.jpg" width="600">

      由图可知，vi的父进程的pid是7854

    + 查询7854的父进程

      ```shell
      ps -eo pid,ppid,user,command | grep -w ^.7854
      ```

      <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g11j5zl9l6j3194028dgf.jpg" width="600">

      由图可知，7854的父进程的pid是7745

    + 查询7745的父进程

      ```shell
      ps -eo pid,ppid,user,command | grep -w ^.7745
      ```

      <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g11j78j2jtj319602adgg.jpg" width="600">

      由图可知，7745的父进程的pid是1

    + 查询1的父进程

      ```
      ps -eo pid,ppid,user,command | grep -w 1
      ```

      <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g11jao6mj9j317o02874s.jpg" width="600">

    综上所述，可以得到如下结果：

    | 进程号 | 父进程号 | 所属用户 | 命令 |
    | ------ | -------- | -------- | ---- |
    | 13716  | 7854     | ubuntu   | vi   |
    | 7854   | 7745     | ubuntu   | -zsh |
    | 7745   | 1        | ubuntu   | tmux |
    | 1      | 0        | root     | init |

    4. 将步骤三得到的进程树和pstree得到的进程树比较

    通过`pstree`命令得到如下结果：

    <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g11jkb37mtj30ja02eq2v.jpg" width="600">

    左边的虚线代表init进程，可以看到两种方式得到的进程树是相同的。

    两种方式各自的优点如下：

    + `pstree`:
      + 进程树比较直观，一目了然
      + 能一次显示所有的进程的进程树
    + `ps`命令查询出的进程树
      + 能查看每个中间进程的详细信息
      + ps命令自主性比较好，可以由用户自定义参数

## Task 2

### 2.1 实验步骤

+ 实验代码如下：

```c
#include<stdio.h>
#include<unistd.h>
int main()
{
	pid_t pid,fpid;//进程id号
	fpid=fork();//创建子进程
	if(fpid<0)
	{
		printf("创建子进程出错！");		
	}
	if(fpid==0)
	{
		int ret;//接收函数返回值
		ret = execl("/usr/bin/vi","vi",NULL);
		if(ret==-1)
			perror("excel l error");
	} 
	if(fpid>0)
	{
		printf("子进程的pid为%d\n",fpid);
		printf("父进程的pid为%d\n",getpid());
		/* 父进程执行空循环 */
		while(1)
			sleep(3);
	}
	return 0;
}
```

+ 编译并运行程序

  <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g16r750fa1j30x00323z0.jpg" width="600">

  <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g16rjvrbykj30wa044mxw.jpg" width="600">

+ 查看vi进程和父进程的状态

  + vi进程

  <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g16r9qvp9pj30uy026dgb.jpg" width="600">

  <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g16rbrws3dj30ym0243yw.jpg" width="600">

  ​	可以看到vi进程的进程号为12703,父进程pid为12702，占用CPU和MEM分别为0.5%和0.6%

  + vi进程父进程

    <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g16ri9e2cdj30xe026mxm.jpg" width="600">

+ 对所有进程按照CPU占用率排序

  + 方法一：使用htop命令，自动按照CPU占用率对进程排序

    <img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g16rl2ocd1j31uw0ocgwl.jpg" width="600">

  + 方法二：使用top命令按照CPU占用率对进程排序

    ​		<img src="https://ws1.sinaimg.cn/large/006CotQ3ly1g16rnp0gjpj31us0oegtt.jpg" width="600">

    ​		

    